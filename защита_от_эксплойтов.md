# Защита от эксплойтов переполнения буфера

В данном документе рассматриваются основные методы защиты от эксплойтов, связанных с переполнением буфера на стеке.

## Основные механизмы защиты

### 1. Канарейки стека (Stack Canaries)

**Описание**: Специальные значения, размещаемые между буфером и данными управления (сохраненный EBP, адрес возврата). Эти значения проверяются перед возвратом из функции.

**Реализация**:
- Компилятор помещает случайное значение на стек после локальных переменных
- Перед возвратом из функции канарейка проверяется
- Если значение изменено, программа аварийно завершается

**Компиляция с защитой**:
```bash
gcc -fstack-protector vuln.c -o vuln_protected
# Или для защиты всех функций
gcc -fstack-protector-all vuln.c -o vuln_protected
```

**Пример проверки канарейки в ассемблере**:
```assembly
; Пролог функции
mov     rax, qword [fs:28h]  ; Получение канарейки
mov     [rbp-8], rax         ; Сохранение канарейки на стеке

; ... тело функции ...

; Эпилог функции
mov     rax, [rbp-8]         ; Загрузка сохраненной канарейки
xor     rax, qword [fs:28h]  ; Сравнение с оригинальной канарейкой
jz      .L2                  ; Если равны, все в порядке
call    __stack_chk_fail     ; Иначе - аварийное завершение
```

### 2. Защита от исполнения данных (NX/DEP)

**Описание**: Запрет на исполнение кода в областях памяти, предназначенных для данных (стек, куча).

**Реализация**:
- Операционная система и процессор разделяют права доступа к памяти (чтение, запись, исполнение)
- Стек и куча помечаются как неисполняемые области

**Компиляция с защитой**:
```bash
# NX включен по умолчанию в современных компиляторах
gcc vuln.c -o vuln_nx_enabled

# Явное отключение NX (для тестирования)
gcc -z execstack vuln.c -o vuln_nx_disabled
```

### 3. Рандомизация адресного пространства (ASLR)

**Описание**: Случайное размещение областей памяти программы при каждом запуске.

**Реализация**:
- Операционная система загружает программу и библиотеки по разным адресам при каждом запуске
- Затрудняет определение адресов целевых функций для эксплуатации

**Включение ASLR в системе**:
```bash
# Проверка статуса ASLR (Linux)
cat /proc/sys/kernel/randomize_va_space

# Включение ASLR (значение 2 - полная рандомизация)
sudo sysctl -w kernel.randomize_va_space=2
```

### 4. Position Independent Executable (PIE)

**Описание**: Компиляция программы с возможностью ее загрузки по любому адресу.

**Реализация**:
- Программа компилируется без фиксированных адресов
- Работает совместно с ASLR для повышения эффективности защиты

**Компиляция с PIE**:
```bash
gcc -fPIE -pie vuln.c -o vuln_pie
```

### 5. Безопасные функции и проверки границ

**Описание**: Использование безопасных альтернатив уязвимым функциям и явные проверки размеров.

**Примеры замен уязвимых функций**:

| Уязвимая функция | Безопасная альтернатива |
|------------------|------------------------|
| `gets(buf)`      | `fgets(buf, size, stdin)` |
| `strcpy(dst, src)` | `strncpy(dst, src, size)` |
| `strcat(dst, src)` | `strncat(dst, src, size)` |
| `sprintf(buf, fmt, ...)` | `snprintf(buf, size, fmt, ...)` |

**Пример безопасного кода**:
```c
char buffer[64];

// Небезопасно
gets(buffer); // Нет проверки размера!

// Безопасная альтернатива
fgets(buffer, sizeof(buffer), stdin);

// Дополнительная проверка размера
if (strlen(buffer) >= sizeof(buffer) - 1) {
    // Обработка ошибки переполнения
}
```

### 6. RELRO (RELocation Read-Only)

**Описание**: Защита секций релокации от перезаписи.

**Типы**:
- **Partial RELRO**: Защищает секции `.got` и `.dtors` (по умолчанию)
- **Full RELRO**: Делает всю таблицу GOT доступной только для чтения

**Компиляция с RELRO**:
```bash
# Partial RELRO (по умолчанию)
gcc -Wl,-z,relro vuln.c -o vuln_partial_relro

# Full RELRO
gcc -Wl,-z,relro,-z,now vuln.c -o vuln_full_relro
```

## Комбинированная защита

Для максимальной защиты рекомендуется использовать комбинацию всех вышеперечисленных механизмов:

```bash
gcc -fstack-protector-all -fPIE -pie -Wl,-z,relro,-z,now vuln.c -o vuln_secure
```

## Проверка наличия защитных механизмов

Для проверки наличия защитных механизмов в бинарном файле можно использовать инструмент `checksec`:

```bash
# Установка checksec (в Debian/Ubuntu)
sudo apt install checksec

# Проверка защитных механизмов
checksec --file=vuln
checksec --file=vuln_secure
```

Пример вывода `checksec`:
```
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY
Full RELRO      Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH   82 Symbols      Yes
```

## Практические рекомендации по защите

1. **Используйте современные компиляторы** с встроенными защитными механизмами

2. **Включайте максимальный уровень предупреждений**:
   ```bash
   gcc -Wall -Wextra -Werror vuln.c -o vuln
   ```

3. **Используйте статические анализаторы кода**:
   - Clang Static Analyzer
   - Coverity
   - Fortify Source

4. **Применяйте инструменты динамического анализа**:
   - AddressSanitizer
   - Valgrind
   - ASAN

5. **Проводите регулярные аудиты безопасности кода**

6. **Следуйте принципам безопасного программирования**:
   - Проверяйте входные данные
   - Используйте безопасные функции
   - Придерживайтесь принципа наименьших привилегий

## Применение AddressSanitizer

AddressSanitizer - мощный инструмент для обнаружения ошибок работы с памятью.

```bash
# Компиляция с AddressSanitizer
gcc -fsanitize=address -g vuln.c -o vuln_asan

# Запуск
./vuln_asan
```

При попытке эксплуатации программы с AddressSanitizer она аварийно завершится с подробным отчетом о проблеме:

```
==8123==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffd42bd2c40
WRITE of size 77 at 0x7ffd42bd2c40 thread T0
    #0 ... in main /.../vuln.c:15
    ...
```

## Заключение

Комбинация различных защитных механизмов значительно снижает вероятность успешной эксплуатации уязвимостей переполнения буфера. Однако важно помнить, что использование безопасных практик программирования остается основой для создания защищенного кода.

Ни один из механизмов по отдельности не дает 100% защиты, поэтому рекомендуется использовать многоуровневый подход к безопасности. 